---
title: "DDD Notes"
date: 2022-03-16T09:15:48+01:00
draft: false
---

(in progress)

* Bounded Context

  Its a subdomain. Ubiquitous language are within bounded context.
  
  There are [[https://en.wikipedia.org/wiki/Polysemy][Polysemes]], same word could can mean different things
  between contexts.

  And shared language between contexts. For example: "Product".

  [[/bounded-context.png]]
  
* Aggregate and Aggregate root

  Aggregates are cluster of entities and values objects and define
  boundaries around each. Goal of aggregate is to protect the
  invariants and guarantee consistency.

  The size of the aggregate has an impact. Big aggregate will have
  issues guaranteeing consistency and forcing transactions on the
  whole aggregate may cause scalibility issues.

  Aggregate roots is the entry point for the aggregate. The root
  entity enforces invariants true and keeps the aggregate consistent,
  however, root can delegate other objects within the aggregate to
  ensure consistency.

  If we find us trying to guarantee transactions between
  aggregates, then it is a sign that some invariants are not thought
  out carefully.

  Aggregate should be cohesive and not split between nodes. 

* Domain Services

  Operations which are external to aggregate and represents a domain
  concept could be encapsulated into domain service. Domain services
  are part of domain model and stateless.

  #+begin_src :name examples
  fn GetCurrentISOWeek() { ... }

  fn CalculateTax(price Money) { ... }
  #+end_src

  In the preceding example, service involving clock could become a
  domain service. This is useful for testing, by patching (monkey
  patching/mocking) using the programming language tools.
