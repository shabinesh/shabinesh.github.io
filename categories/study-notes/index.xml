<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>study notes on Sab's</title><link>http://shabinesh.github.io/categories/study-notes/</link><description>Recent content in study notes on Sab's</description><generator>Hugo -- gohugo.io</generator><language>en-in</language><lastBuildDate>Tue, 19 May 2020 17:10:38 +0200</lastBuildDate><atom:link href="http://shabinesh.github.io/categories/study-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang Reflect</title><link>http://shabinesh.github.io/blog/notes/golang-reflect/</link><pubDate>Tue, 19 May 2020 17:10:38 +0200</pubDate><guid>http://shabinesh.github.io/blog/notes/golang-reflect/</guid><description>Reflection in Golang Incase you are here looking to learn about reflection, a better resource is https://blog.golang.org/laws-of-reflection Interfaces in Go are types which hold concrete value and underlying type of the value with a precondition that value should implement methods of the interface. For example; types implementing Read([]byte) (int, error) method satisfy the io.Reader interface. However interface{}, without any method definition will match all types.
A struct type can be assigned to an empty interface, the assertion is the concrete type should implement the methods of the interface type.</description></item></channel></rss>